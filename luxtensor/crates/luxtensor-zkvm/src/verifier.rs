//! Zero-Knowledge Verifier implementation
//!
//! Provides on-chain compatible proof verification for ZK proofs.

use std::time::Instant;
use tracing::{debug, info, warn};

use crate::{
    types::{ImageId, ProofReceipt, ProofType, VerificationResult},
    Result,
};
use luxtensor_core::Hash;
use luxtensor_crypto::keccak256;

/// Configuration for the verifier
#[derive(Debug, Clone)]
pub struct VerifierConfig {
    /// List of trusted image IDs
    pub trusted_images: Vec<ImageId>,
    /// Allow dev-mode proofs (testing only)
    pub allow_dev_proofs: bool,
    /// Require SNARK-wrapped proofs
    pub require_groth16: bool,
    /// Maximum proof age in seconds (0 = no limit)
    pub max_proof_age_seconds: u64,
    /// Maximum proof seal size in bytes (prevent DoS via large proofs)
    pub max_seal_size_bytes: usize,
    /// Minimum proof seal size in bytes (reject trivially small proofs)
    pub min_seal_size_bytes: usize,
    /// Enable proof replay protection (track seen proof hashes)
    pub replay_protection: bool,
    /// Maximum number of cached proof hashes for replay protection
    pub replay_cache_size: usize,
}

impl Default for VerifierConfig {
    fn default() -> Self {
        Self {
            trusted_images: Vec::new(),
            allow_dev_proofs: false,
            require_groth16: false,
            max_proof_age_seconds: 0,
            max_seal_size_bytes: 2 * 1024 * 1024,  // 2 MB — realistic STARK proof upper bound
            min_seal_size_bytes: 16,               // minimum meaningful proof
            replay_protection: true,
            replay_cache_size: 100_000,
        }
    }
}

impl VerifierConfig {
    /// Create a development configuration that allows dev proofs.
    ///
    /// # Security Warning
    /// Dev mode accepts proofs without real cryptographic verification.
    /// **MUST NOT** be used in production node configuration.
    /// The production node in `service.rs` uses `VerifierConfig::default()`.
    pub fn dev_mode() -> Self {
        Self {
            trusted_images: Vec::new(),
            allow_dev_proofs: true,
            require_groth16: false,
            max_proof_age_seconds: 0,
            max_seal_size_bytes: 16 * 1024 * 1024,
            min_seal_size_bytes: 1,
            replay_protection: false,
            replay_cache_size: 0,
        }
    }

    /// Add a trusted image ID
    pub fn trust_image(mut self, image_id: ImageId) -> Self {
        self.trusted_images.push(image_id);
        self
    }

    /// Set whether to require Groth16 proofs
    pub fn require_snark(mut self, require: bool) -> Self {
        self.require_groth16 = require;
        self
    }

    /// Set maximum proof age
    pub fn max_age(mut self, seconds: u64) -> Self {
        self.max_proof_age_seconds = seconds;
        self
    }
}

/// Zero-Knowledge Proof Verifier
///
/// Verifies ZK proofs generated by the ZkProver. Designed to be efficient
/// for on-chain verification.
///
/// # Verification Modes
///
/// - **Dev Mode**: Verifies deterministic hash-based proofs
/// - **STARK Mode**: Verifies RISC Zero STARK proofs
/// - **Groth16 Mode**: Verifies SNARK-wrapped Groth16 proofs
pub struct ZkVerifier {
    config: VerifierConfig,
    /// Total verifications performed
    verification_count: std::sync::atomic::AtomicU64,
    /// Successful verifications
    success_count: std::sync::atomic::AtomicU64,
    /// Failed verifications
    failure_count: std::sync::atomic::AtomicU64,
    /// Proof hashes seen (replay protection)
    seen_proofs: parking_lot::RwLock<std::collections::HashSet<Hash>>,
}

impl ZkVerifier {
    /// Create a new verifier with the given configuration
    pub fn new(config: VerifierConfig) -> Self {
        info!(
            trusted_images = config.trusted_images.len(),
            allow_dev = config.allow_dev_proofs,
            require_groth16 = config.require_groth16,
            "Initializing ZkVerifier"
        );

        Self {
            config,
            verification_count: std::sync::atomic::AtomicU64::new(0),
            success_count: std::sync::atomic::AtomicU64::new(0),
            failure_count: std::sync::atomic::AtomicU64::new(0),
            seen_proofs: parking_lot::RwLock::new(std::collections::HashSet::new()),
        }
    }

    /// Create a verifier with default configuration
    pub fn default_verifier() -> Self {
        Self::new(VerifierConfig::default())
    }

    /// Create a development verifier that allows dev proofs.
    ///
    /// Create a development verifier that allows dev proofs.
    ///
    /// # Security Warning
    /// **MUST NOT** be used in production. Use `default_verifier()` instead.
    pub fn dev_verifier() -> Self {
        Self::new(VerifierConfig::dev_mode())
    }

    /// Verify a proof receipt
    ///
    /// # Arguments
    /// * `receipt` - The proof receipt to verify
    ///
    /// # Returns
    /// A `VerificationResult` indicating whether the proof is valid
    pub fn verify(&self, receipt: &ProofReceipt) -> Result<VerificationResult> {
        let start = Instant::now();
        debug!(image_id = %receipt.image_id, "Starting verification");

        // Pre-verification checks
        if let Some(result) = self.pre_verify_checks(receipt) {
            self.update_stats(false);
            return Ok(result);
        }

        // Perform actual verification based on proof type
        let result = match receipt.proof.proof_type {
            ProofType::Dev => self.verify_dev_proof(receipt),
            ProofType::Stark => self.verify_stark_proof(receipt),
            ProofType::Groth16 => self.verify_groth16_proof(receipt),
        };

        let is_valid = result.as_ref().map(|r| r.is_valid).unwrap_or(false);
        self.update_stats(is_valid);

        // Track verified proof hash for replay protection
        if is_valid && self.config.replay_protection {
            let proof_hash = keccak256(&receipt.proof.seal);
            let mut seen = self.seen_proofs.write();
            seen.insert(proof_hash);
            // Bounded eviction: remove ~25% oldest entries when cache is full.
            // SECURITY: Never clear() the entire set — that creates a total
            // amnesia event allowing replay of all previously seen proofs.
            if seen.len() > self.config.replay_cache_size && self.config.replay_cache_size > 0 {
                let to_remove = seen.len() / 4;
                let remove_keys: Vec<Hash> = seen.iter().take(to_remove).copied().collect();
                for key in remove_keys {
                    seen.remove(&key);
                }
            }
        }

        let duration = start.elapsed();
        info!(
            image_id = %receipt.image_id,
            valid = is_valid,
            time_us = duration.as_micros(),
            proof_type = ?receipt.proof.proof_type,
            "Verification complete"
        );

        result
    }

    /// Pre-verification checks
    fn pre_verify_checks(&self, receipt: &ProofReceipt) -> Option<VerificationResult> {
        // Check proof type
        match receipt.proof.proof_type {
            ProofType::Dev => {
                if !self.config.allow_dev_proofs {
                    return Some(VerificationResult::invalid(
                        receipt.image_id,
                        "Dev proofs not allowed in production".to_string(),
                    ));
                }
            }
            ProofType::Stark => {
                if self.config.require_groth16 {
                    return Some(VerificationResult::invalid(
                        receipt.image_id,
                        "SNARK-wrapped proof required".to_string(),
                    ));
                }
            }
            ProofType::Groth16 => {
                // Groth16 proofs always allowed
            }
        }

        // Check trusted images if configured
        if !self.config.trusted_images.is_empty()
            && !self.config.trusted_images.contains(&receipt.image_id)
        {
            warn!(image_id = %receipt.image_id, "Untrusted image ID");
            return Some(VerificationResult::invalid(
                receipt.image_id,
                "Image ID not in trusted list".to_string(),
            ));
        }

        // Check proof size bounds
        if receipt.proof.seal.is_empty() {
            return Some(VerificationResult::invalid(
                receipt.image_id,
                "Empty proof seal".to_string(),
            ));
        }
        if receipt.proof.seal.len() < self.config.min_seal_size_bytes {
            return Some(VerificationResult::invalid(
                receipt.image_id,
                format!(
                    "Proof seal too small ({} < {} bytes)",
                    receipt.proof.seal.len(),
                    self.config.min_seal_size_bytes
                ),
            ));
        }
        if receipt.proof.seal.len() > self.config.max_seal_size_bytes {
            warn!(
                seal_size = receipt.proof.seal.len(),
                max = self.config.max_seal_size_bytes,
                "Proof seal exceeds maximum size — potential DoS"
            );
            return Some(VerificationResult::invalid(
                receipt.image_id,
                format!(
                    "Proof seal too large ({} > {} bytes)",
                    receipt.proof.seal.len(),
                    self.config.max_seal_size_bytes
                ),
            ));
        }

        // Replay protection: reject proofs we've already verified
        if self.config.replay_protection {
            let proof_hash = keccak256(&receipt.proof.seal);
            let seen = self.seen_proofs.read();
            if seen.contains(&proof_hash) {
                warn!(image_id = %receipt.image_id, "Duplicate proof detected (replay)");
                return Some(VerificationResult::invalid(
                    receipt.image_id,
                    "Proof already verified (replay detected)".to_string(),
                ));
            }
        }

        None
    }

    /// Update verification statistics
    fn update_stats(&self, success: bool) {
        self.verification_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        if success {
            self.success_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        } else {
            self.failure_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        }
    }

    /// Verify a development-mode proof
    ///
    /// Dev proofs use deterministic hashing: seal = keccak256(image_id || journal)
    fn verify_dev_proof(&self, receipt: &ProofReceipt) -> Result<VerificationResult> {
        let start = Instant::now();

        // Compute expected seal
        let expected_seal = keccak256(&[&receipt.image_id.0[..], &receipt.journal[..]].concat());

        if receipt.proof.seal == expected_seal.to_vec() {
            let journal_hash = keccak256(&receipt.journal);
            Ok(VerificationResult::valid(
                receipt.image_id,
                journal_hash,
                start.elapsed().as_micros() as u64,
            ))
        } else {
            Ok(VerificationResult::invalid(receipt.image_id, "Dev proof seal mismatch".to_string()))
        }
    }

    /// Verify a RISC Zero STARK proof
    ///
    /// When the `risc0` feature is enabled, this performs cryptographic verification.
    /// Otherwise, it performs basic structural validation.
    fn verify_stark_proof(&self, receipt: &ProofReceipt) -> Result<VerificationResult> {
        let start = Instant::now();

        #[cfg(feature = "risc0")]
        {
            return self.verify_risc0_stark(receipt, start);
        }

        #[cfg(not(feature = "risc0"))]
        {
            // Without risc0 feature, perform structural validation
            self.verify_stark_structural(receipt, start)
        }
    }

    /// Structural STARK proof validation (when risc0 feature disabled)
    ///
    /// SECURITY: Without the risc0 cryptographic verifier, we CANNOT validate
    /// STARK proofs. All proofs are rejected to prevent accepting unverified work.
    /// Enable the `risc0` feature for production use.
    #[cfg(not(feature = "risc0"))]
    fn verify_stark_structural(
        &self,
        receipt: &ProofReceipt,
        _start: Instant,
    ) -> Result<VerificationResult> {
        tracing::warn!(
            "STARK proof verification attempted without `risc0` feature enabled. \
             Proof REJECTED. Enable the `risc0` feature for cryptographic verification."
        );

        Ok(VerificationResult::invalid(
            receipt.image_id,
            "STARK verification unavailable: `risc0` feature not enabled. \
             Cannot cryptographically verify proof — rejecting for safety."
                .to_string(),
        ))
    }

    /// RISC Zero STARK verification (when feature enabled)
    #[cfg(feature = "risc0")]
    fn verify_risc0_stark(
        &self,
        receipt: &ProofReceipt,
        start: Instant,
    ) -> Result<VerificationResult> {
        use risc0_zkvm::Receipt;
        use crate::ZkVmError;

        // Deserialize the receipt from the seal bytes
        let inner: risc0_zkvm::InnerReceipt =
            bincode::deserialize(&receipt.proof.seal).map_err(|e| {
                ZkVmError::VerificationFailed(format!(
                    "Failed to deserialize STARK proof: {}", e
                ))
            })?;

        let risc0_receipt = Receipt {
            inner,
            journal: risc0_zkvm::Journal::new(receipt.journal.clone()),
        };

        // Verify the receipt against the expected image ID.
        // Receipt::verify takes impl Into<Digest> where Digest is [u32; 8].
        // Our ImageId is [u8; 32], which converts to Digest via .into()
        match risc0_receipt.verify(receipt.image_id.0) {
            Ok(()) => {
                let journal_hash = keccak256(&receipt.journal);
                Ok(VerificationResult::valid(
                    receipt.image_id,
                    journal_hash,
                    start.elapsed().as_micros() as u64,
                ))
            }
            Err(e) => {
                Ok(VerificationResult::invalid(
                    receipt.image_id,
                    format!("STARK verification failed: {}", e),
                ))
            }
        }
    }

    /// Verify a Groth16-wrapped SNARK proof
    ///
    /// Groth16 proofs are smaller (~200 bytes) and faster to verify than STARK proofs.
    fn verify_groth16_proof(&self, receipt: &ProofReceipt) -> Result<VerificationResult> {
        let start = Instant::now();

        #[cfg(feature = "groth16")]
        {
            return self.verify_risc0_groth16(receipt, start);
        }

        #[cfg(not(feature = "groth16"))]
        {
            // Structural validation for Groth16
            self.verify_groth16_structural(receipt, start)
        }
    }

    /// Structural Groth16 validation (when groth16 feature disabled)
    ///
    /// SECURITY: Without the groth16 cryptographic verifier, we CANNOT validate
    /// Groth16 proofs. All proofs are rejected to prevent accepting unverified work.
    /// Enable the `groth16` feature for production use.
    #[cfg(not(feature = "groth16"))]
    fn verify_groth16_structural(
        &self,
        receipt: &ProofReceipt,
        _start: Instant,
    ) -> Result<VerificationResult> {
        tracing::warn!(
            "Groth16 proof verification attempted without `groth16` feature enabled. \
             Proof REJECTED. Enable the `groth16` feature for cryptographic verification."
        );

        Ok(VerificationResult::invalid(
            receipt.image_id,
            "Groth16 verification unavailable: `groth16` feature not enabled. \
             Cannot cryptographically verify proof — rejecting for safety."
                .to_string(),
        ))
    }

    /// RISC Zero Groth16 verification (when feature enabled)
    #[cfg(feature = "groth16")]
    fn verify_risc0_groth16(
        &self,
        receipt: &ProofReceipt,
        start: Instant,
    ) -> Result<VerificationResult> {
        use risc0_groth16::Groth16Receipt;
        use crate::ZkVmError;

        let groth16_receipt: Groth16Receipt =
            bincode::deserialize(&receipt.proof.seal).map_err(|e| {
                ZkVmError::VerificationFailed(format!(
                    "Failed to deserialize Groth16 proof: {}", e
                ))
            })?;

        match groth16_receipt.verify(&receipt.journal, receipt.image_id.0) {
            Ok(()) => {
                let journal_hash = keccak256(&receipt.journal);
                Ok(VerificationResult::valid(
                    receipt.image_id,
                    journal_hash,
                    start.elapsed().as_micros() as u64,
                ))
            }
            Err(e) => {
                Ok(VerificationResult::invalid(
                    receipt.image_id,
                    format!("Groth16 verification failed: {}", e),
                ))
            }
        }
    }

    /// Batch verify multiple receipts
    ///
    /// Returns a vector of verification results, one for each receipt.
    pub fn batch_verify(&self, receipts: &[ProofReceipt]) -> Result<Vec<VerificationResult>> {
        info!(count = receipts.len(), "Starting batch verification");

        let mut results = Vec::with_capacity(receipts.len());
        for receipt in receipts {
            results.push(self.verify(receipt)?);
        }

        let valid_count = results.iter().filter(|r| r.is_valid).count();
        info!(
            total = receipts.len(),
            valid = valid_count,
            invalid = receipts.len() - valid_count,
            "Batch verification complete"
        );

        Ok(results)
    }

    /// Get the number of verifications performed
    pub fn verification_count(&self) -> u64 {
        self.verification_count.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Get the number of successful verifications
    pub fn success_count(&self) -> u64 {
        self.success_count.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Get the number of failed verifications
    pub fn failure_count(&self) -> u64 {
        self.failure_count.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Get the success rate (0.0 - 1.0)
    pub fn success_rate(&self) -> f64 {
        let total = self.verification_count();
        if total == 0 {
            return 0.0;
        }
        self.success_count() as f64 / total as f64
    }

    /// Compute the journal hash for a given journal
    pub fn compute_journal_hash(journal: &[u8]) -> Hash {
        keccak256(journal)
    }

    /// Check if an image ID is trusted
    pub fn is_trusted(&self, image_id: &ImageId) -> bool {
        self.config.trusted_images.is_empty() || self.config.trusted_images.contains(image_id)
    }

    /// Add a trusted image at runtime
    pub fn trust_image(&mut self, image_id: ImageId) {
        if !self.config.trusted_images.contains(&image_id) {
            self.config.trusted_images.push(image_id);
        }
    }

    /// Remove a trusted image
    pub fn untrust_image(&mut self, image_id: &ImageId) {
        self.config.trusted_images.retain(|id| id != image_id);
    }

    /// Get verifier configuration
    pub fn config(&self) -> &VerifierConfig {
        &self.config
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{Proof, ProofMetadata};

    fn create_test_receipt(proof_type: ProofType) -> ProofReceipt {
        let image_id = ImageId::new([1u8; 32]);
        let journal = vec![1, 2, 3, 4];

        let seal = match proof_type {
            ProofType::Dev => keccak256(&[&image_id.0[..], &journal[..]].concat()).to_vec(),
            _ => vec![0u8; 64],
        };

        ProofReceipt {
            image_id,
            journal,
            proof: Proof { seal, proof_type },
            metadata: ProofMetadata::default(),
        }
    }

    #[test]
    fn test_verifier_creation() {
        let verifier = ZkVerifier::default_verifier();
        assert!(!verifier.config.allow_dev_proofs);
    }

    #[test]
    fn test_dev_proof_allowed() {
        let verifier = ZkVerifier::dev_verifier();
        let receipt = create_test_receipt(ProofType::Dev);

        let result = verifier.verify(&receipt).unwrap();
        assert!(result.is_valid);
    }

    #[test]
    fn test_dev_proof_rejected_in_production() {
        let verifier = ZkVerifier::default_verifier();
        let receipt = create_test_receipt(ProofType::Dev);

        let result = verifier.verify(&receipt).unwrap();
        assert!(!result.is_valid);
        assert!(result.error.unwrap().contains("Dev proofs not allowed"));
    }

    #[test]
    fn test_untrusted_image_rejected() {
        let trusted_id = ImageId::new([2u8; 32]);
        let config = VerifierConfig::default().trust_image(trusted_id);
        let verifier = ZkVerifier::new(config);

        let receipt = create_test_receipt(ProofType::Stark);

        let result = verifier.verify(&receipt).unwrap();
        assert!(!result.is_valid);
    }

    #[test]
    fn test_trusted_image_accepted() {
        let image_id = ImageId::new([1u8; 32]);
        let config = VerifierConfig::dev_mode().trust_image(image_id);
        let verifier = ZkVerifier::new(config);

        let receipt = create_test_receipt(ProofType::Dev);

        let result = verifier.verify(&receipt).unwrap();
        assert!(result.is_valid);
    }

    #[test]
    fn test_batch_verify() {
        let verifier = ZkVerifier::dev_verifier();

        let receipts: Vec<_> = (0..5).map(|_| create_test_receipt(ProofType::Dev)).collect();

        let results = verifier.batch_verify(&receipts).unwrap();
        assert_eq!(results.len(), 5);
        assert!(results.iter().all(|r| r.is_valid));
    }

    #[test]
    fn test_verification_count() {
        let verifier = ZkVerifier::dev_verifier();

        assert_eq!(verifier.verification_count(), 0);

        let receipt = create_test_receipt(ProofType::Dev);
        verifier.verify(&receipt).unwrap();
        verifier.verify(&receipt).unwrap();

        assert_eq!(verifier.verification_count(), 2);
    }

    #[test]
    fn test_success_failure_counts() {
        let verifier = ZkVerifier::dev_verifier();

        // Successful verification
        let valid_receipt = create_test_receipt(ProofType::Dev);
        verifier.verify(&valid_receipt).unwrap();

        // Failed verification (empty seal)
        let mut invalid_receipt = create_test_receipt(ProofType::Dev);
        invalid_receipt.proof.seal = vec![];
        verifier.verify(&invalid_receipt).unwrap();

        assert_eq!(verifier.success_count(), 1);
        assert_eq!(verifier.failure_count(), 1);
        assert_eq!(verifier.verification_count(), 2);
        assert!((verifier.success_rate() - 0.5).abs() < 0.01);
    }

    #[test]
    fn test_journal_hash() {
        let journal = vec![1, 2, 3, 4];
        let hash = ZkVerifier::compute_journal_hash(&journal);
        assert_ne!(hash, [0u8; 32]);
    }

    #[test]
    fn test_empty_seal_rejected() {
        let verifier = ZkVerifier::dev_verifier();

        let mut receipt = create_test_receipt(ProofType::Dev);
        receipt.proof.seal = vec![];

        let result = verifier.verify(&receipt).unwrap();
        assert!(!result.is_valid);
        assert!(result.error.unwrap().contains("Empty proof seal"));
    }

    #[test]
    fn test_trust_untrust_image() {
        let mut verifier = ZkVerifier::default_verifier();
        let image_id = ImageId::new([1u8; 32]);

        assert!(verifier.is_trusted(&image_id)); // Empty list = all trusted

        verifier.trust_image(ImageId::new([2u8; 32]));
        assert!(!verifier.is_trusted(&image_id)); // Now only [2u8; 32] is trusted

        verifier.trust_image(image_id);
        assert!(verifier.is_trusted(&image_id));

        verifier.untrust_image(&image_id);
        assert!(!verifier.is_trusted(&image_id));
    }

    #[test]
    fn test_require_groth16() {
        let config = VerifierConfig::default().require_snark(true);
        let verifier = ZkVerifier::new(config);

        let receipt = create_test_receipt(ProofType::Stark);
        let result = verifier.verify(&receipt).unwrap();

        assert!(!result.is_valid);
        assert!(result.error.unwrap().contains("SNARK-wrapped"));
    }
}
